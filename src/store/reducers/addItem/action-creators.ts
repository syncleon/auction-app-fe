import { AppDispatch } from "../../index";
import { API_ENDPOINTS } from "../../../apiService";
import { Item } from "../../../models/IItem";
import axios from "axios";
import {
    ItemActionEnum,
    SetItemErrorAction,
    SetItemIsLoadingAction,
    SetItemAction,
    SetItemSuccessAction
} from "./types";

export const AddItemActionCreators = {
    setItem: (item: Item): SetItemAction => ({
        type: ItemActionEnum.SET_ITEM,
        payload: item
    }),

    setItemIsLoading: (itemIsLoading: boolean): SetItemIsLoadingAction => ({
        type: ItemActionEnum.SET_ITEM_IS_LOADING,
        payload: itemIsLoading
    }),

    setItemIsError: (itemError: string): SetItemErrorAction => ({
        type: ItemActionEnum.SET_ITEM_ERROR,
        payload: itemError
    }),

    setItemSuccess: (itemMessage: string): SetItemSuccessAction => ({
        type: ItemActionEnum.SET_ITEM_IS_SUCCESS,
        payload: itemMessage
    }),

    addItem: (
        make: string,
        model: string,
        mileage: string,
        year: string,
        price: string,
        exteriorColor: string, // New field
        interiorColor: string, // New field
        engineSize: string,
        fuelType: string,
        transmission: string, // Updated field name
        condition: string,
        drivetrain: string, // New field
        bodyStyle: string, // New field
        location: string,
        description: string,
        vin: string,
        images: {
            featured: FileList | null,
            exterior: FileList | null,
            interior: FileList | null,
            mechanical: FileList | null,
            other: FileList | null
        }
    ) => async (dispatch: AppDispatch) => {
        try {
            dispatch(AddItemActionCreators.setItemIsLoading(true));

            // Construct payload data including new fields
            const payloadData: Item = {
                id: '', // Assuming ID is generated by the backend
                make,
                model,
                mileage,
                year,
                price,
                exteriorColor, // New field
                interiorColor, // New field
                engineSize,
                fuelType,
                transmission, // Updated field name
                condition,
                drivetrain, // New field
                bodyStyle, // New field
                location,
                description,
                vin,
                onAuction: false, // Default value, if applicable
                isSold: false, // Default value, if applicable
                images: [] // Assuming images will be handled separately
            };

            const formData = new FormData();

            // Add payload data as JSON blob
            formData.append("payload", new Blob([JSON.stringify(payloadData)], { type: "application/json" }));

            // Append each category of images
            for (const [category, files] of Object.entries(images)) {
                if (files) {
                    Array.from(files).forEach(file => {
                        formData.append(`images_${category}`, file);
                    });
                }
            }

            const token = localStorage.getItem("token");
            const headers = {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'multipart/form-data'
            };

            const response = await axios.post<Item>(API_ENDPOINTS.ITEMS, formData, { headers });
            const newItem: Item = response.data;

            dispatch(AddItemActionCreators.setItem(newItem));
            dispatch(AddItemActionCreators.setItemSuccess('Item Added Successfully!'));
        } catch (error) {
            if (axios.isAxiosError(error) && error.response) {
                const statusText = error.response.data;
                dispatch(AddItemActionCreators.setItemIsError(statusText));
            } else {
                dispatch(AddItemActionCreators.setItemIsError('An unexpected error occurred'));
            }
        } finally {
            dispatch(AddItemActionCreators.setItemIsLoading(false));
        }
    }
};
